<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The db lifetime on tracked/interned structs - Salsa</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../mermaid.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../about_salsa.html"><strong aria-hidden="true">1.</strong> About salsa</a></li><li class="chapter-item expanded affix "><li class="part-title">How to use Salsa</li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial: calc language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorial/structure.html"><strong aria-hidden="true">3.1.</strong> Basic structure</a></li><li class="chapter-item expanded "><a href="../tutorial/jar.html"><strong aria-hidden="true">3.2.</strong> Jars and databases</a></li><li class="chapter-item expanded "><a href="../tutorial/db.html"><strong aria-hidden="true">3.3.</strong> Defining the database struct</a></li><li class="chapter-item expanded "><a href="../tutorial/ir.html"><strong aria-hidden="true">3.4.</strong> Defining the IR: the various &quot;salsa structs&quot;</a></li><li class="chapter-item expanded "><a href="../tutorial/parser.html"><strong aria-hidden="true">3.5.</strong> Defining the parser: memoized functions and inputs</a></li><li class="chapter-item expanded "><a href="../tutorial/accumulators.html"><strong aria-hidden="true">3.6.</strong> Defining the parser: reporting errors</a></li><li class="chapter-item expanded "><a href="../tutorial/debug.html"><strong aria-hidden="true">3.7.</strong> Defining the parser: debug impls and testing</a></li><li class="chapter-item expanded "><a href="../tutorial/checker.html"><strong aria-hidden="true">3.8.</strong> Defining the checker</a></li><li class="chapter-item expanded "><a href="../tutorial/interpreter.html"><strong aria-hidden="true">3.9.</strong> Defining the interpreter</a></li></ol></li><li class="chapter-item expanded "><a href="../reference.html"><strong aria-hidden="true">4.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/durability.html"><strong aria-hidden="true">4.1.</strong> Durability</a></li><li class="chapter-item expanded "><a href="../reference/algorithm.html"><strong aria-hidden="true">4.2.</strong> Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="../common_patterns.html"><strong aria-hidden="true">5.</strong> Common patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../common_patterns/selection.html"><strong aria-hidden="true">5.1.</strong> Selection</a></li><li class="chapter-item expanded "><a href="../common_patterns/on_demand_inputs.html"><strong aria-hidden="true">5.2.</strong> On-demand (Lazy) inputs</a></li></ol></li><li class="chapter-item expanded "><a href="../tuning.html"><strong aria-hidden="true">6.</strong> Tuning</a></li><li class="chapter-item expanded "><a href="../cycles.html"><strong aria-hidden="true">7.</strong> Cycle handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cycles/fallback.html"><strong aria-hidden="true">7.1.</strong> Recovering via fallback</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">How Salsa works internally</li><li class="chapter-item expanded "><a href="../how_salsa_works.html"><strong aria-hidden="true">8.</strong> How Salsa works</a></li><li class="chapter-item expanded "><a href="../videos.html"><strong aria-hidden="true">9.</strong> Videos</a></li><li class="chapter-item expanded "><a href="../plumbing.html"><strong aria-hidden="true">10.</strong> Plumbing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../plumbing/jars_and_ingredients.html"><strong aria-hidden="true">10.1.</strong> Jars and ingredients</a></li><li class="chapter-item expanded "><a href="../plumbing/database_and_runtime.html"><strong aria-hidden="true">10.2.</strong> Databases and runtime</a></li><li class="chapter-item expanded "><a href="../plumbing/db_lifetime.html" class="active"><strong aria-hidden="true">10.3.</strong> The db lifetime on tracked/interned structs</a></li><li class="chapter-item expanded "><a href="../plumbing/tracked_structs.html"><strong aria-hidden="true">10.4.</strong> Tracked structures</a></li><li class="chapter-item expanded "><a href="../plumbing/query_ops.html"><strong aria-hidden="true">10.5.</strong> Query operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../plumbing/maybe_changed_after.html"><strong aria-hidden="true">10.5.1.</strong> maybe changed after</a></li><li class="chapter-item expanded "><a href="../plumbing/fetch.html"><strong aria-hidden="true">10.5.2.</strong> Fetch</a></li><li class="chapter-item expanded "><a href="../plumbing/derived_flowchart.html"><strong aria-hidden="true">10.5.3.</strong> Derived queries flowchart</a></li><li class="chapter-item expanded "><a href="../plumbing/cycles.html"><strong aria-hidden="true">10.5.4.</strong> Cycle handling</a></li></ol></li><li class="chapter-item expanded "><a href="../plumbing/terminology.html"><strong aria-hidden="true">10.6.</strong> Terminology</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../plumbing/terminology/backdate.html"><strong aria-hidden="true">10.6.1.</strong> Backdate</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/changed_at.html"><strong aria-hidden="true">10.6.2.</strong> Changed at</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/dependency.html"><strong aria-hidden="true">10.6.3.</strong> Dependency</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/derived_query.html"><strong aria-hidden="true">10.6.4.</strong> Derived query</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/durability.html"><strong aria-hidden="true">10.6.5.</strong> Durability</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/input_query.html"><strong aria-hidden="true">10.6.6.</strong> Input query</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/ingredient.html"><strong aria-hidden="true">10.6.7.</strong> Ingredient</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/LRU.html"><strong aria-hidden="true">10.6.8.</strong> LRU</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/memo.html"><strong aria-hidden="true">10.6.9.</strong> Memo</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/query.html"><strong aria-hidden="true">10.6.10.</strong> Query</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/query_function.html"><strong aria-hidden="true">10.6.11.</strong> Query function</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/revision.html"><strong aria-hidden="true">10.6.12.</strong> Revision</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/salsa_item.html"><strong aria-hidden="true">10.6.13.</strong> Salsa item</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/salsa_struct.html"><strong aria-hidden="true">10.6.14.</strong> Salsa struct</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/untracked.html"><strong aria-hidden="true">10.6.15.</strong> Untracked dependency</a></li><li class="chapter-item expanded "><a href="../plumbing/terminology/verified.html"><strong aria-hidden="true">10.6.16.</strong> Verified</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../meta.html"><strong aria-hidden="true">11.</strong> Meta: about the book itself</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Salsa</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-db-lifetime"><a class="header" href="#the-db-lifetime">The <code>'db</code> lifetime</a></h1>
<p><a href="./tracked_structs.html">Tracked</a> and interned structs are both declared with a <code>'db</code> lifetime.
This lifetime is linked to the <code>db: &amp;DB</code> reference used to create them.
The <code>'db</code> lifetime has several implications:</p>
<ul>
<li>It ensures that the user does not create a new salsa revision while a tracked/interned struct is in active use. Creating a new salsa revision requires modifying an input which requires an <code>&amp;mut DB</code> reference, therefore it cannot occur during <code>'db</code>.
<ul>
<li>The struct may not even exist in the new salsa revision so allowing access would be confusing.</li>
</ul>
</li>
<li>It permits the structs to be implemented using a pointer rather than a <code>salsa::Id</code>, which in turn means more efficient field access (no read locks required).</li>
</ul>
<p>This section discusses the unsafe code used for pointer-based access along with the reasoning behind it. To be concrete, we'll focus on tracked structs -- interned structs are very similar.</p>
<h2 id="a-note-on-ub"><a class="header" href="#a-note-on-ub">A note on UB</a></h2>
<p>When we say in this page &quot;users cannot do X&quot;, we mean without Undefined Behavior (e.g., by transmuting integers around etc).</p>
<h2 id="proof-obligations"><a class="header" href="#proof-obligations">Proof obligations</a></h2>
<p>Here is a typical sequence of operations for a tracked struct along with the user operations that will require us to prove unsafe assertions:</p>
<ul>
<li>A tracked function <code>f</code> executes in revision R0 and creates a tracked struct with <code>#[id]</code> fields <code>K</code> for the first time.
<ul>
<li><code>K</code> will be stored in the interning hashmap and mapped to a fresh identifier <code>id</code>.</li>
<li>The identifier <code>id</code> will be used as the key in the <code>StructMap</code> and point to a freshly created allocation <code>alloc : Alloc</code>.</li>
<li>A <code>ts: TS&lt;'db&gt;</code> is created from the raw pointer <code>alloc</code> and returned to the user.</li>
</ul>
</li>
<li>The value of the field <code>field</code> is accessed on the tracked struct instance <code>ts</code> by invoking the method <code>ts.field(db)</code>
<ul>
<li><em>Unsafe:</em> This accesses the raw pointer to <code>alloc</code>.* A new revision R1 begins.</li>
</ul>
</li>
<li>The tracked function <code>f</code> does not re-execute in R1.</li>
<li>The value of the field <code>field</code> is accessed on the tracked struct instance <code>ts</code> by invoking the method <code>ts.field(db)</code>
<ul>
<li><em>Unsafe:</em> This accesses the raw pointer to <code>alloc</code>.* A new revision R2 begins.</li>
</ul>
</li>
<li>The tracked function <code>f</code> does reexecute in R2 and it again creates a tracked struct with key <code>K</code> and with (Some) distinct field values.
<ul>
<li>The fields for <code>ts</code> are updated.</li>
</ul>
</li>
<li>The value of the field <code>field</code> is accessed on the tracked struct instance <code>ts</code> by invoking the method <code>ts.field(db)</code>
<ul>
<li><em>Unsafe:</em> This accesses the raw pointer to <code>alloc</code>.</li>
</ul>
</li>
<li>A new revision R3 begins.</li>
<li>When <code>f</code> executes this time it does NOT create a tracked struct with key <code>K</code>. The tracked struct <code>ts</code> is placed in the &quot;to be deleted&quot; list.</li>
<li>A new revision R4 begins:
<ul>
<li>The allocation <code>alloc</code> is freed.</li>
</ul>
</li>
</ul>
<p>As noted in the list, the core &quot;unsafe&quot; operation that users can perform is to access the fields of a tracked struct.
Tracked structs store a raw pointer to the <code>alloc</code>, owned by the ingredient, that contains their field data.
Accessing the fields of a tracked struct returns a <code>&amp;</code>-reference to fields stored in that <code>alloc</code>, which means we must ensure Rust's two core constraints are satisfied for the lifetime of that reference:</p>
<ul>
<li>The allocation <code>alloc</code> will not be freed (i.e., not be dropped)</li>
<li>The contents of the fields will not be mutated</li>
</ul>
<p>As the sequence above illustrates, we have to show that those two constraints are true in a variety of circumstances:</p>
<ul>
<li>newly created tracked structs</li>
<li>tracked structs that were created in prior revisions and re-validated in this revision</li>
<li>tracked structs whose fields were updated in this revision</li>
<li>tracked structs that were <em>not</em> created in this revision</li>
</ul>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>For every tracked struct <code>ts</code> we say that it has a <strong>defining query</strong> <code>f(..)</code>. 
This refers to a particular invocation of the tracked function <code>f</code> with a particular set of arguments <code>..</code>.
This defining query is unique within a revision, meaning that <code>f</code> executes at most once with that same set of arguments.</p>
<p>We say that a query has <em>executed in a revision R</em> if its function body was executed. When this occurs, all tracked structs defined (created) by that query will be recorded along with the query's result.</p>
<p>We say that a query has been <em>validated in a revision R</em> if the salsa system determined that its inputs did not change and so skipped executing it. This also triggers the tracked structs defined by that query to be considered validated (in particular, we execute a function on them which updates some internal fields, as described below).</p>
<p>When we talk about <code>ts</code>, we mean </p>
<h2 id="theorem-at-the-start-of-a-new-revision-all-references-to-ts-are-within-salsas-database"><a class="header" href="#theorem-at-the-start-of-a-new-revision-all-references-to-ts-are-within-salsas-database">Theorem: At the start of a new revision, all references to <code>ts</code> are within salsa's database</a></h2>
<p>After <code>ts</code> is deleted, there may be other memoized values still reference <code>ts</code>, but they must have a red input query.
<strong>Is this true even if there are user bugs like non-deterministic functions?</strong>
Argument: yes, because of non-forgery, those memoized values could not be accessed.
How did those memoized values obtain the <code>TS&lt;'db&gt;</code> value in the first place?
It must have come from a function argument (XX: what about thread-local state).
Therefore, to access the value, they would have to provide those function arguments again.
But how did they get them?</p>
<p>Potential holes:</p>
<ul>
<li>Thread-local APIs that let you thread <code>'db</code> values down in an &quot;invisible&quot; way, so that you can return them without them showing up in your arguments -- e.g. a tracked function <code>() -&gt; S&lt;'db&gt;</code> that obtains its value from thread-local state.
<ul>
<li>We might be able to sanity check against this with enough effort by defining some traits that guarantee that every lifetime tagged thing in your result <em>could have</em> come from one of your arguments, but I don't think we can prove it altogether. We either have to tell users &quot;don't do that&quot; or we need to have some kind of dynamic check, e.g. with a kind of versioned pointer. Note that it does require unsafe code at present but only because of the limits of our existing APIs.</li>
<li>Alternatively we can do a better job cleaning up deleted stuff. This we could do.</li>
</ul>
</li>
<li>what about weird <code>Eq</code> implementations and the like? Do we have to make those unsafe?</li>
</ul>
<h2 id="theorem-to-access-a-tracked-struct-ts-in-revision-r-the-defining-query-f-must-have-either-executed-or-been-validated-in-the-revision-r"><a class="header" href="#theorem-to-access-a-tracked-struct-ts-in-revision-r-the-defining-query-f-must-have-either-executed-or-been-validated-in-the-revision-r">Theorem: To access a tracked struct <code>ts</code> in revision R, the defining query <code>f(..)</code> must have either <em>executed</em> or been <em>validated</em> in the revision R.</a></h2>
<p>This is the core bit of reasoning underlying most of what follows.
The idea is that users cannot &quot;forge&quot; a tracked struct instance <code>ts</code>.
They must have gotten it through salsa's internal mechanisms.
This is important because salsa will provide <code>&amp;</code>-references to fields within that remain valid during a revision.
But at the start of a new revision salsa may opt to modify those fields or even free the allocation.
This is safe because users cannot have references to <code>ts</code> at the start of a new revision.</p>
<h3 id="lemma"><a class="header" href="#lemma">Lemma</a></h3>
<p>We will prove it by proceeding through the revisions in the life cycle above (this can be considered a proof by induction).</p>
<h3 id="before-ts-is-first-created-in-r0"><a class="header" href="#before-ts-is-first-created-in-r0">Before <code>ts</code> is first created in R0</a></h3>
<p>Users must have originally obtained <code>ts: TS&lt;'db&gt;</code> by invoking <code>TS::new(&amp;db, ...)</code>.
This is because creating an instance of <code>TS</code> requires providing a <code>NonNull&lt;salsa::tracked_struct::ValueStruct&gt;</code> pointer 
to an unsafe function whose contract requires the pointer's validity.</p>
<p><strong>FIXME:</strong> This is not strictly true, I think the constructor is just a private tuple ctor, we should fix that.</p>
<h3 id="during-r0"><a class="header" href="#during-r0">During R0</a></h3>
<h3 id=""><a class="header" href="#"></a></h3>
<h3 id="inductive-case-consider-some-revision-r"><a class="header" href="#inductive-case-consider-some-revision-r">Inductive case: Consider some revision R</a></h3>
<p>We start by showing some circumstances that cannot occur:</p>
<ul>
<li>accessing the field of a tracked struct <code>ts</code> that was never created</li>
<li>accessing the field of a tracked struct <code>ts</code> after it is freed</li>
</ul>
<h3 id="lemma-no-forgery-users-cannot-forge-a-tracked-struct"><a class="header" href="#lemma-no-forgery-users-cannot-forge-a-tracked-struct">Lemma (no forgery): Users cannot forge a tracked struct</a></h3>
<p>The first observation is that users cannot &quot;forge&quot; an instance of a tracked struct <code>ts</code>.
They are required to produce a pointer to an <code>Alloc</code>.
This implies that every tracked struct <code>ts</code> originated in the ingredient.
The same is not true for input structs, for example, because they are created from integer identifiers and users could just make those up.</p>
<h3 id="lemma-within-one-rev-users-cannot-hold-a-tracked-struct-ts-across-revisions"><a class="header" href="#lemma-within-one-rev-users-cannot-hold-a-tracked-struct-ts-across-revisions">Lemma (within one rev): Users cannot hold a tracked struct <code>ts</code> across revisions</a></h3>
<p>The lifetime <code>'db</code> of the tracked struct <code>ts: TS&lt;'db&gt;</code> is created from a <code>db: &amp;'db dyn Db</code> handle.
Beginning a new revision requires an <code>&amp;mut</code> reference.
Therefore so long as users are actively using the value <code>ts</code> the database cannot start a new revision.</p>
<p><em>Check:</em> What if users had two databases and invoked internal methods? Maybe they could then. We may have to add some assertions.</p>
<h3 id="theorem-in-order-to-get-a-tracked-struct-ts-in-revision-r0-the-tracked-fn-f-that-creates-it-must-either-execute-or-be-validated-first"><a class="header" href="#theorem-in-order-to-get-a-tracked-struct-ts-in-revision-r0-the-tracked-fn-f-that-creates-it-must-either-execute-or-be-validated-first">Theorem: In order to get a tracked struct <code>ts</code> in revision R0, the tracked fn <code>f</code> that creates it must either <em>execute</em> or <em>be validated</em> first</a></h3>
<p>The two points above combine to </p>
<h2 id="creating-new-values"><a class="header" href="#creating-new-values">Creating new values</a></h2>
<p>Each new value is stored in a <code>salsa::alloc::Alloc</code> created by <code>StructMap::insert</code>.
<code>Alloc</code> is a variant of the standard Rust <code>Box</code> that carries no uniqueness implications.
This means that every tracked struct has its own allocation.
This allocation is owned by the tracked struct ingredient
and thus stays live until the tracked struct ingredient is dropped
or until it is removed (see later for safety conditions around removal).</p>
<h2 id="the-user-type-uses-a-raw-pointer"><a class="header" href="#the-user-type-uses-a-raw-pointer">The user type uses a raw pointer</a></h2>
<p>The <code>#[salsa::tracked]</code> macro creates a user-exposed struct that looks roughly like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This struct is a wrapper around the actual fields that adds
// some revision metadata. You can think of it as a newtype'd
// version of the fields of the tracked struct.
use salsa::tracked_struct::ValueStruct;

struct MyTrackedStruct&lt;'db&gt; {
    value: *const ValueStruct&lt;..&gt;,
    phantom: PhantomData&lt;&amp;'db ValueStruct&lt;...&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Key observations:</p>
<ul>
<li>The actual pointer to the <code>ValueStruct</code> used at runtime is not a Rust reference but a raw pointer. This is needed for stacked borrows.</li>
<li>A <code>PhantomData</code> is used to keep the <code>'db</code> lifetime alive.</li>
</ul>
<p>The reason we use a raw pointer in the struct is because instances of this struct will outlive the <code>'db</code> lifetime. Consider this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut db = MyDatabase::default();
let input = MyInput::new(&amp;mut db, ...);

// Revision 1:
let result1 = tracked_fn(&amp;db, input);

// Revision 2:
input.set_field(&amp;mut db).to(...);
let result2 = tracked_fn(&amp;db, input);
<span class="boring">}
</span></code></pre></pre>
<p>Tracked structs created by <code>tracked_fn</code> during Revision 1
may be reused during Revision 2, but the original <code>&amp;db</code> reference
used to create them has expired.
If we stored a true Rust reference, that would be a violation of
the stacked borrows rules.</p>
<p>Instead, we store a raw pointer and,
whenever users invoke the accessor methods for particular fields,
we create a new reference to the contents:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'db&gt; MyTrackedStruct&lt;'db&gt; {
    fn field(self, db: &amp;'db dyn DB) -&gt; &amp;'db FieldType {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This reference is linked to <code>db</code> and remains valid so long as the </p>
<h2 id="the-db-lifetime-at-rest"><a class="header" href="#the-db-lifetime-at-rest">The <code>'db</code> lifetime at rest</a></h2>
<h2 id="updating-tracked-struct-fields-across-revisions"><a class="header" href="#updating-tracked-struct-fields-across-revisions">Updating tracked struct fields across revisions</a></h2>
<h3 id="the-xx"><a class="header" href="#the-xx">The <code>XX</code></a></h3>
<h2 id="safety-lemmas"><a class="header" href="#safety-lemmas">Safety lemmas</a></h2>
<p>These lemmas are used to justify the safety of the system.</p>
<h3 id="using-mytrackeddb-within-some-revision-r-always-happens-after-a-call-to-mytrackednew"><a class="header" href="#using-mytrackeddb-within-some-revision-r-always-happens-after-a-call-to-mytrackednew">Using <code>MyTracked&lt;'db&gt;</code> within some revision R always &quot;happens after' a call to <code>MyTracked::new</code></a></h3>
<p>Whenever a tracked struct instance <code>TS&lt;'db&gt;</code> is created for the first time in revision R1,
the result is a fresh allocation and hence there cannot be any
pre-existing aliases of that struct.</p>
<p><code>TS&lt;'db&gt;</code> will at that time be stored into the salsa database.
In later revisions, we assert that </p>
<h3 id="db-t-references-are-never-stored-in-the-database"><a class="header" href="#db-t-references-are-never-stored-in-the-database"><code>&amp;'db T</code> references are never stored in the database</a></h3>
<p>We maintain the invariant that, in any later revision R2, </p>
<p>However in some later revision R2, how </p>
<h2 id="ways-this-could-go-wrong-and-how-we-prevent-them"><a class="header" href="#ways-this-could-go-wrong-and-how-we-prevent-them">Ways this could go wrong and how we prevent them</a></h2>
<h3 id="-1"><a class="header" href="#-1"></a></h3>
<h3 id="storing-an-db-t-into-a-field"><a class="header" href="#storing-an-db-t-into-a-field">Storing an <code>&amp;'db T</code> into a field</a></h3>
<h3 id="freeing-the-memory-while-a-tracked-struct-remains-live"><a class="header" href="#freeing-the-memory-while-a-tracked-struct-remains-live">Freeing the memory while a tracked struct remains live</a></h3>
<h3 id="aliases-of-a-tracked-struct"><a class="header" href="#aliases-of-a-tracked-struct">Aliases of a tracked struct</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../plumbing/database_and_runtime.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../plumbing/tracked_structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../plumbing/database_and_runtime.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../plumbing/tracked_structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../mermaid.min.js"></script>
                <script type="text/javascript" src="../mermaid-init.js"></script>
        
        
    </body>
</html>
